#include <iostream>
#include <fstream>
#include <string>
using namespace std;

const char digit[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f' };
//перевод из символа в целое число
int charToInt(char c) {
	for (int j = 0; j < 22; ++j) {
		if (digit[j] == c) {
			if (j < 16)
				return j;
			if (j >= 16)
				return j - 6;
		}
	}
	return -1;
}
//перевод из целого числа в символ
char intToChar(int i) {
	if (i >= 0 && i <= 15)
	{
		return digit[i];
	}
	return -1;
}
//функция проверяет введённое число на соответствие с.с. b1
bool isValid(string &number, int b1) {
	if (number.empty()) {
		return 0;
	}
	if (number.find('.') != number.rfind('.'))
	{
		return 0;
	}
	bool cellIsNull = true, floatIsNull = true;
	bool belongToCell = true;
	for (int i = 0; i < number.length(); ++i) {
		if (number[i] == '.') {
			belongToCell = false;
			continue;
		}
		if (charToInt(number[i]) >= b1) {
			return false;
		}
		if (belongToCell == true) {
			cellIsNull = false;
		}
		else {
			floatIsNull = false;
		}
	}
	if (cellIsNull) {
		return false;
	}
	if (floatIsNull && !belongToCell)
	{
		return false;
	}
	return true;
}
void main() {
	string orig;// начальное число
	int b1 = 0, b2 = 0;
	ifstream fin("in.txt");
	ofstream fout("out.txt");
	fin >> b1 >> b2;
	//проверяем введённые системы счисления на вшивость
	if (b1 < 2 || b1 > 16 || b2 < 2 || b2 > 16) {
		fout << "bad input";
		return;
	}
	fin >> orig;
	// 0 = 0 в любой с.с.
	if (orig == "0") {
		fout << '0';
		return;
	}
	//проверяем введённое число на вшивость
	if (isValid(orig, b1) == 0) {
		fout << "bad input";
		return;
	}
	// если b1 = b2, то очевидно, что ответ - то же самое число
	if (b1 == b2) {
		cout << orig;
	}
	//записываем целую часть в один массив, дробную - в другой
	string orig_cell; // целая часть начального числа
	string orig_float; // дробная часть начального числа
	int dot = orig.find('.');
	if (dot != -1) {
		orig_cell.resize(dot);
		orig.copy(&orig_cell[0], dot, 0);
		orig_float.resize(orig.size() - dot - 1);
		orig.copy(&orig_float[0], orig.size() - dot - 1, dot + 1);
	}
	else {
		orig_cell.resize(orig.size());
		orig.copy(&orig_cell[0], orig.size(), 0);
	}
	/*
	переведём целую часть числа в десятичную систему счисления
	*/
	long long cell_decNum = 0; // целая часть началього числа в десятичном виде
	for (int i = 0; i < orig_cell.length(); i++)
	{
		cell_decNum = cell_decNum*b1 + charToInt(orig_cell[i]);
	}
	/*
	переведём дробную часть числа в десятичную систему счисления
	*/
	double float_decNum = 0;// дробная часть началього числа в десятичном виде
	for (int i = orig_float.length() - 1; i >= 0; i--)
	{
		float_decNum = float_decNum / b1 + charToInt(orig_float[i]);
	}
	float_decNum = float_decNum / b1;

	//если нет целой части числа
	string cell_result; // результат для целой части
	if (cell_decNum == 0) {
		cell_result = '0';
		goto noDecPart;
	}
	/*
	Весьма небезопасно использовать while(true)
	переводим из десятичной записи в любую другую
	*/
	while (true) {
		//если остаток от деления числа на b2 = 0 и 
		//деление нацело на b2 = 0, то завершаем цикл
		if (cell_decNum%b2 == 0 && cell_decNum / b2 == 0) {
			break;
		}
		cell_result += intToChar(cell_decNum%b2);
		//делим число нацело
		cell_decNum = cell_decNum / b2;
	}
	noDecPart:
	/*
	Весьма небезопасно использовать while(true)
	переводим из десятичной записи в любую другую
	*/
	string float_result; // результат для дробной части
	for(int i = 0; i <= 12; ++i)
	{
		//если кол-во цифр полсле запятой > 12 или дробная часть стала равно нулю
		//то выходим из цикла
		if (i >= 12 || float_decNum == 0) {
			break;
		}
		float_result += intToChar((int)(float_decNum*b2));
		//домножаем на основание новой системы счисления и отнимаем целую часть 
		float_decNum = float_decNum*b2 - (int)(float_decNum*b2);
	}
	//запишем результат в обратном порядке
	reverse(cell_result.begin(), cell_result.end());
	//выведем результат
	fout << cell_result;
	if (float_result.length() != 0) {
		fout << '.' << float_result;
	}
	fin.close();
	fout.close();
}